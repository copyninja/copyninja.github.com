--- 
layout: post
title: "Packet sniffer using pcap utility"
published: true
meta: 
  blogger_author: Vasudev Kamathhttp://www.blogger.com/profile/05106578827322209004noreply@blogger.com
  blogger_blog: blog.copyninja.info
  blogger_permalink: /2009/03/packet-sniffer-using-pcap-utility.html
tags: 
- packet sniffer
- pcap utility
type: post
status: publish
---
><div mce_style="text-align: justify" style="text-align: justify;">As a part of my project I needed to do a packet sniffer. Ifirst thought of using RAW SOCKETS for this purpose but later found that they have portability issue. Then I came accross pcap utility from tcpdump.org. Each distro has support for this utility. You need to get package libpcap-dev (i.e pcap development package). I did the coding in Debian Lenny so I needed to execute following command to get pcap library for my system.</div><blockquote>apt-get install libpcap*</blockquote><div mce_style="text-align: justify" style="text-align: justify;">To get the executable of your program you need to link it pcap library during the compilation which is done by providing -lpcap switch to the gcc or cc compiler.</div><blockquote>gcc -ggdb main.c -o sniffer -lpcap</blockquote><div mce_style="text-align: justify" style="text-align: justify;">-ggdb switch generates file containing debugging symbols used by gdb utility.</div><div mce_style="text-align: justify" style="text-align: justify;">Ok before jumping into coding part we need to know about few basic data structures and functions that we will use in the coding part. Let me start with a simple example.<img class="mceWPmore mceItemNoResize" mce_src="http://vasudevkamath.techfiz.com/wp-includes/js/tinymce/plugins/wordpress/img/trans.gif" src="http://vasudevkamath.techfiz.com/wp-includes/js/tinymce/plugins/wordpress/img/trans.gif" title="More..." /></div><pre name="code" class="c">#include &lt;pcap.h&gt;<br />int main(int argc,char **argv)<br />{<br />   pcap_t *handle;<br />   char *dev,errbuf[PCAP_ERRBUF_SIZE];<br />   u_char *packet;<br />   struct pcap_pkthdr hdr;<br />   dev = pcap_lookupdev(errbuf);<br />   if(dev == NULL){<br />     fprintf(stderr,"pcap_looupdev(): %s\n",errbuf);<br />     exit(1);<br />   }<br />   handle = pcap_open_live(dev,BUFSIZ,0,0,null);<br />   if(handle == NULL) {<br />     fprintf(stderr,"Failed to open %s\n",dev);<br />     exit(1);<br />   }<br />   while(1){<br />     packet = pcap_next(handle,&amp;hdr);<br />     /* ...<br />      * Process the captured packet here<br />      */<br />   }<br />}</pre><div mce_style="text-align: justify" style="text-align: justify;">Here the <b>pcap_t</b> is integer data type (similar) which holds the handle for the opened network interface. The structure <b>pcap_pkthdr</b> is defined as follows( man page of pcap.h)<br /><pre name="code" class="c">struct pcap_pkthdr {<br />   struct timeval ts; /* time stamp */<br />   bpf_u_int32 caplen; /* length of portion present */<br />   bpf_u_int32 len; /* length this packet (off wire) */<br />};</pre></div><div mce_style="text-align: justify" style="text-align: justify;">Well in my project I used only the time stamp field in this structure. Function <b>pcap_lookupdev</b> looks for the default interface of your system, so you don't have to worry about specifying interface to the program. If the function encounters error the error message is copied into the errbuf field. This function returs string i.e name of the interface in linux system default interface will be <b>eth0</b>.</div><div mce_style="text-align: justify" style="text-align: justify;">The function <b>pcap_open_live</b> opens the specified device for reading (capturing the packet) it returns handle to the device which will be used later to capture the packet from the interface. Prototype is as follows (pcap.h man page)</div><div mce_style="text-align: justify" style="text-align: justify;"><span class="Apple-style-span" mce_style="color: #000000;font-family: 'times new roman';font-size: 16px;font-style: normal;font-variant: normal;font-weight: normal" style="color: black; font-family: 'times new roman'; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal;"><br /><pre name="code" class="c">pcap_t *pcap_open_live(char *device, int snaplen, int promisc, int to_ms,char *ebuf)</pre></span></div><div mce_style="text-align: justify" style="text-align: justify;">Once this much is done you need to enter&nbsp; into infinite loop and use function <b>pcap_next </b>to capture packet. This function returns pointer to the captured packet, return type is u_char*. The prototype of function is as follows<br /><code> u_char *pcap_next(pcap_t *p, struct pcap_pkthdr *h)</code> </div><div mce_style="text-align: justify" style="text-align: justify;">Once you have captured the packet next is to extract information from it. I'll explain in my next post about the extraction of protocol related fields from the packet. Till then bye and have a nice day :)</div>
